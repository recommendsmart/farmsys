<?php

/**
 * @file
 * Contains ginvite.module.
 */

use Drupal\Component\Utility\Html;
use Drupal\Core\Access\AccessResult;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Render\BubbleableMetadata;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Url;
use Drupal\ginvite\Event\UserLoginWithInvitationEvent;
use Drupal\ginvite\Event\UserRegisteredFromInvitationEvent;
use Drupal\ginvite\Plugin\Group\Relation\GroupInvitation;
use Drupal\group\Access\GroupAccessResult;
use Drupal\group\Entity\GroupInterface;
use Drupal\group\Entity\GroupRelationshipInterface;
use Drupal\user\UserInterface;

/**
 * Implements hook_help().
 */
function ginvite_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    case 'help.page.ginvite':
      $text = file_get_contents(__DIR__ . '/README.md');
      if (!\Drupal::moduleHandler()->moduleExists('markdown')) {
        return '<pre>' . Html::escape($text) . '</pre>';
      }
      else {
        // Use the Markdown filter to render the README.
        $filter_manager = \Drupal::service('plugin.manager.filter');
        $settings = \Drupal::configFactory()->get('markdown.settings')->getRawData();
        $config = ['settings' => $settings];
        $filter = $filter_manager->createInstance('markdown', $config);
        return $filter->process($text, 'en');
      }
  }
  return NULL;
}

/**
 * Implements hook_form_BASE_FORM_ID_alter() for group_content_form.
 */
function ginvite_form_group_content_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  /** @var \Drupal\Core\Entity\ContentEntityFormInterface $form_object */
  $form_object = $form_state->getFormObject();
  /** @var \Drupal\group\Entity\GroupRelationshipInterface $group_relationship */
  $group_relationship = $form_object->getEntity();
  if ($group_relationship->getPluginId() === 'group_invitation') {
    $form += [
      // Reference to Anonymous user by default.
      'entity_id' => [
        '#type' => 'value',
        '#value' => 0,
      ],
    ];

    $group = $group_relationship->getGroup();
    // Forbid users without the permission to assign roles to users they are
    // inviting.
    if ($group instanceof GroupInterface && !GroupAccessResult::allowedIfHasGroupPermission($group, \Drupal::currentUser(), 'administer members')->isAllowed()) {
      $form['group_roles']['#access'] = FALSE;
    }
  }
}

/**
 * Sets the invitation status to PENDING for new invitations.
 *
 * Implements hook_ENTITY_TYPE_presave().
 */
function ginvite_group_content_presave(GroupRelationshipInterface $group_relationship) {
  \Drupal::service('ginvite.invitation_handler')->handleGroupInvitation($group_relationship);
}

/**
 * Sends email when invitation created for not registered user.
 *
 * Implements hook_ENTITY_TYPE_insert().
 */
function ginvite_group_content_insert(GroupRelationshipInterface $group_relationship) {
  // If new membership is created, check related invitation exists.
  if ($group_relationship->getPluginId() == 'group_membership') {
    $properties = [
      'entity_id' => $group_relationship->getEntity()->id(),
      'gid' => $group_relationship->getGroup()->id(),
      'invitation_status' => GroupInvitation::INVITATION_PENDING,
    ];

    $invitations = \Drupal::service('ginvite.invitation_loader')->loadByProperties($properties);
    if (!empty($invitations)) {
      foreach ($invitations as $invitation) {
        // Remove group content if setting is enabled.
        if ($invitation->getGroupRelationship()->getPlugin()->getConfiguration()['remove_invitation'] == 1) {
          $invitation->getGroupRelationship()->delete();
        }
        elseif ($invitation->getGroupRelationship()->get('invitation_status')->value !== GroupInvitation::INVITATION_ACCEPTED) {
          // Mark invitation as accepted.
          $invitation->getGroupRelationship()->set('invitation_status', GroupInvitation::INVITATION_ACCEPTED)->save();
        }
      }

      \Drupal::messenger()->addMessage(t('You have accepted the invitation.'));
    }
  }
}

/**
 * Send cancellation email when the invitation is removed.
 *
 * Implements hook_ENTITY_TYPE_delete().
 */
function ginvite_group_content_delete(GroupRelationshipInterface $group_relationship) {
  $plugin_id = $group_relationship->getPluginId();
  if ($plugin_id == 'group_invitation') {
    $group = $group_relationship->getGroup();
    // Load plugin configuration.
    $group_invite_config = $group_relationship->getPlugin()->getConfiguration();

    if ($group_invite_config['send_cancel_email'] && $group_relationship->get('invitation_status')->value == GroupInvitation::INVITATION_PENDING) {
      $from = $group_relationship->getEntity();

      if ($from instanceof UserInterface) {
        $mail = $group_relationship->get('invitee_mail')->getString();
        $params = [
          'user' => $from,
          'group' => $group,
          'group_content' => $group_relationship,
        ];
        \Drupal::service('plugin.manager.mail')->mail('ginvite', 'cancel', $mail, $from->getPreferredLangcode(), $params, NULL, TRUE);
      }
    }
  }

  // Remove invitation when member is removed.
  if ($plugin_id == 'group_membership') {
    $properties = [
      'entity_id' => $group_relationship->getEntityId(),
      'gid' => $group_relationship->getGroupId(),
    ];

    // Remove invitations, when we remove the user.
    $invitations = \Drupal::service('ginvite.invitation_loader')->loadByProperties($properties);
    foreach ($invitations as $invitation) {
      $invitation->getGroupRelationship()->delete();
    }
  }
}

/**
 * Implements hook_mail().
 *
 * This mail is sent when people who do not have an account on the website yet
 * are invited into a group. It is sent in the language the inviter was using
 * the website in.
 *
 * @see ginvite_group_content_insert()
 */
function ginvite_mail($key, &$message, $params) {
  if ($key == 'invite' || $key == 'cancel') {
    $token_service = \Drupal::token();
    $language_manager = \Drupal::languageManager();

    // Get email from GroupInvitation.
    $group = $params['group'];
    $langcode = $message['langcode'];

    $language = $language_manager->getLanguage($langcode);
    $original_language = $language_manager->getConfigOverrideLanguage();
    $language_manager->setConfigOverrideLanguage($language);

    // Load plugin configuration.
    $group_plugin_collection = \Drupal::service('group_relation_type.manager')->getInstalled($group->getGroupType());
    $group_invite_config = $group_plugin_collection->getConfiguration()['group_invitation'];

    $language_manager->setConfigOverrideLanguage($original_language);
    $subject = '';
    $body = '';
    if ($key == 'cancel') {
      $subject = $group_invite_config['cancel_user_invitation_subject'];
      $body = $group_invite_config['cancel_user_invitation_body'];
    }

    if ($key == 'invite') {
      $subject = (!$params['existing_user']) ? $group_invite_config['invitation_subject'] : $group_invite_config['existing_user_invitation_subject'];
      $body = (!$params['existing_user']) ? $group_invite_config['invitation_body'] : $group_invite_config['existing_user_invitation_body'];

      unset($params['existing_user']);
    }

    $body = $token_service->replace($body, $params);
    $subject = $token_service->replace($subject, $params);

    $message['subject'] = $subject;
    $message['body'][] = $body;
  }
}

/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function ginvite_user_insert(UserInterface $user) {
  _ginvite_handle_new_user_registration_or_update($user);
}

/**
 * Implements hook_ENTITY_TYPE_update().
 */
function ginvite_user_update(UserInterface $user) {
  _ginvite_handle_new_user_registration_or_update($user);
}

/**
 * Handles when a new user registers or an existing gets updated.
 *
 * Sets entity reference property on pending invitations of a previously
 * non-existing user by email.
 *
 * @param \Drupal\user\UserInterface $user
 *   A user.
 */
function _ginvite_handle_new_user_registration_or_update(UserInterface $user) {
  // If a user is created without e-mail (because the field is optional or
  // because they are created through SSO) then we can not use the mail to check
  // for pending invites, so we exit early.
  if ($user->get('mail')->isEmpty()) {
    return;
  }

  $properties = [
    'invitee_mail' => $user->getEmail(),
    'invitation_status' => GroupInvitation::INVITATION_PENDING,
    // For security reasons we only allow to get the ownership of invitations
    // that previously belonged to a non-existing user, once the owner is set
    // they cannot be reassigned (for example, by simply changing email
    // addresses).
    'entity_id' => 0,
  ];

  /** @var \Drupal\ginvite\GroupInvitation[] $invitations */
  $invitations = \Drupal::service('ginvite.invitation_loader')->loadByProperties($properties);
  /** @var \Drupal\Component\EventDispatcher\ContainerAwareEventDispatcher $event_dispatcher */
  $event_dispatcher = \Drupal::service('event_dispatcher');
  foreach ($invitations as $invitation) {
    $group_relationship = $invitation->getGroupRelationship();
    $group_relationship->set('entity_id', $user->id());
    $group_relationship->save();
    // Dispatch an event when the user is registered from an invitation.
    // It is not that simple identifying that due to some SSO implementation
    // that usually creates a stub user first and only starts filling in
    // fields on the object, so $user->isNew() is not a viable option here.
    // @todo Should we trigger new event when an existing users change their
    //   email address to one that belongs to a pending invitation?
    if ($user->getLastLoginTime() === 0) {
      $event = new UserRegisteredFromInvitationEvent($invitation);
      $event_dispatcher->dispatch($event, UserRegisteredFromInvitationEvent::EVENT_NAME);
    }
  }
}

/**
 * Add Constraint to prevent duplicated invitations.
 *
 * Implements hook_entity_type_alter().
 */
function ginvite_entity_type_alter(array &$entity_types) {
  $group_content = $entity_types['group_content'];
  $group_content->addConstraint('PreventDuplicated', []);
}

/**
 * Add token to register url.
 *
 * Implements hook_token_info().
 */
function ginvite_token_info() {
  $tokens = [];
  $tokens['register_link'] = [
    'name' => t('Register Link'),
    'description' => t('Url to register page with prefilled email address.'),
  ];
  $tokens['my_invitations_link'] = [
    'name' => t('My Invitations Link'),
    'description' => t('Url to user list of invitations.'),
  ];

  return [
    'tokens' => ['group_content' => $tokens],
  ];
}

/**
 * Implements hook_tokens().
 */
function ginvite_tokens($type, $tokens, array $data, array $options, BubbleableMetadata $bubbleable_metadata) {
  $replacements = [];
  if ($type == 'group_content' && !empty($data[$type])) {
    /** @var \Drupal\group\Entity\GroupRelationshipInterface $group_relationship */
    $group_relationship = $data['group_content'];

    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'register_link':
          $mail = $group_relationship->get('invitee_mail')->getString();
          $search = ['+', '/', '='];
          $replace = ['-', '_', ''];
          $mail_encoded = str_replace($search, $replace, base64_encode($mail));
          $params = ['invitee_mail' => $mail_encoded];

          $register_link = Url::fromRoute('user.register', $params, ['absolute' => TRUE])->toString();
          $replacements[$original] = $register_link;
          break;

        case 'my_invitations_link':
          $url_options = ['absolute' => TRUE];
          $url_options['query']['destination'] = Url::fromRoute('view.my_invitations.page_1')->toString();
          $my_invitations_link = Url::fromRoute('user.login', [], $url_options)->toString();
          $replacements[$original] = $my_invitations_link;
      }
    }
  }
  return $replacements;
}

/**
 * Prefill email address when user comes from ginvite registrarion url.
 *
 * Implements hook_form_FORM_ID_alter().
 */
function ginvite_form_user_register_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $invitee_mail = \Drupal::request()->query->get('invitee_mail');
  if (isset($invitee_mail)) {
    $search = ['-', '_'];
    $replace = ['+', '/'];
    $invitee_mail = base64_decode(str_replace($search, $replace, $invitee_mail));
    if (\Drupal::service('email.validator')->isValid($invitee_mail)) {
      $form['account']['mail']['#default_value'] = $invitee_mail;
      $form['account']['mail']['#disabled'] = TRUE;
    }

    $form['#cache']['max-age'] = 0;
  }
}

/**
 * Remove invites that are expired based on group type configuration.
 *
 * Implements hook_cron().
 */
function ginvite_cron() {
  $state = \Drupal::state();
  $last_check = $state->get('ginvite.last_expire_removal', 0);
  $interval = 60 * 60 * 24;
  $request_time = \Drupal::time()->getRequestTime();

  // Only run this once a day.
  if (($request_time - $last_check) < $interval) {
    return;
  }

  $entity_type_manager = \Drupal::entityTypeManager();
  $group_type_storage = $entity_type_manager->getStorage('group_type');
  $group_relationship_storage = $entity_type_manager->getStorage('group_content');
  $group_relationship_type_storage = $entity_type_manager->getStorage('group_content_type');
  $group_relation_type_manager = \Drupal::service('group_relation_type.manager');
  /** @var \Drupal\group\Entity\GroupTypeInterface $group_type */
  foreach ($group_type_storage->loadMultiple() as $group_type) {
    // Foreach group type get the configuration for the invites expired time.
    $group_plugin_collection = $group_relation_type_manager->getInstalled($group_type);
    $days = $group_plugin_collection->getConfiguration()['group_invitation']['invitation_expire'] ?? NULL;
    $keep_invitations = (bool) ($group_plugin_collection->getConfiguration()['group_invitation']['invitation_expire_keep'] ?? FALSE);

    // Nothing configured? Skip.
    if (!$days) {
      continue;
    }

    // Query for all the invites that are expired for this group type.
    $relation_type_id = $group_relationship_type_storage->getRelationshipTypeId($group_type->id(), 'group_invitation');
    $expired_invites = $group_relationship_storage->getQuery()
      ->accessCheck(FALSE)
      ->condition('type', $relation_type_id)
      ->condition('invitation_status', GroupInvitation::INVITATION_PENDING)
      ->condition('created', $request_time - ($days * $interval), '<')
      ->execute();

    // No expired invites? Skip.
    if (empty($expired_invites)) {
      continue;
    }

    $group_invitations = $group_relationship_storage->loadMultiple($expired_invites);
    if ($keep_invitations) {
      foreach ($group_invitations as $invitation) {
        // Mark invitation as expired.
        $invitation->set('invitation_status', GroupInvitation::INVITATION_EXPIRED)->save();
      }
    }
    else {
      // Permanently remove all expired invites.
      $group_relationship_storage->delete($group_invitations);
    }
  }

  // Set the time that we removed the expired invites so we don't do it too
  // often.
  $state->set('ginvite.last_expire_removal', $request_time);
}

/**
 * Implements hook_user_login().
 */
function ginvite_user_login(UserInterface $user) {
  // If a user is created without e-mail (because the field is optional or
  // because they are created through SSO) then we can not use the mail to check
  // for pending invites, so we exit early.
  if ($user->get('mail')->isEmpty()) {
    return;
  }

  $properties = [
    'invitee_mail' => $user->getEmail(),
    'invitation_status' => GroupInvitation::INVITATION_PENDING,
    'entity_id' => $user->id(),
  ];

  /** @var \Drupal\ginvite\GroupInvitation[] $invitations */
  $invitations = \Drupal::service('ginvite.invitation_loader')->loadByProperties($properties);
  /** @var \Drupal\Component\EventDispatcher\ContainerAwareEventDispatcher $event_dispatcher */
  $event_dispatcher = \Drupal::service('event_dispatcher');
  foreach ($invitations as $invitation) {
    $event = new UserLoginWithInvitationEvent($invitation);
    $event_dispatcher->dispatch($event, UserLoginWithInvitationEvent::EVENT_NAME);
  }
}

/**
 * Implements hook_ENTITY_TYPE_access().
 */
function ginvite_group_access(EntityInterface $entity, $operation, AccountInterface $account) {
  if ($operation == 'view' || $operation == 'view label') {
    // Anonymous users should not get access through pending invitations.
    // Invitations for non-existent users are stored with entity_id = 0,
    // which would incorrectly match all anonymous users.
    if ($account->isAnonymous()) {
      return AccessResult::neutral();
    }

    $properties = [
      'entity_id' => $account->id(),
      'gid' => $entity->id(),
      'invitation_status' => GroupInvitation::INVITATION_PENDING,
    ];

    $invitations = \Drupal::service('ginvite.invitation_loader')->loadByProperties($properties);
    if (!empty($invitations)) {
      return AccessResult::allowed();
    }
  }

  return AccessResult::neutral();
}
